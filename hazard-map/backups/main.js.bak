// Define the bounds of UP Diliman (approximate)
var bounds = [
    [14.645541284855522, 121.05357969734676], // southwest corner
    [14.662347587500506, 121.07857195809305]  // northeast corner
];

// Default center for the map (UP Diliman)
var defaultCenter = [14.6556, 121.0733];

// Create map centered on UP Diliman with restricted zoom and bounds
var map = L.map('map', {
    center: defaultCenter, // center coordinates
    zoom: 16,               // starting zoom
    minZoom: 15,            // can't zoom out too far
    maxZoom: 19,            // can't zoom in too close (match tile availability)
    maxBounds: bounds,      // restrict map panning
    maxBoundsViscosity: 0.8 // controls how "sticky" the edges are             
});

// Add OpenStreetMap tiles
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '¬© OpenStreetMap contributors',
    maxZoom: 19,
    maxNativeZoom: 19
}).addTo(map);

// Ensure the map is correctly sized and centered when ready (fixes any layout/centering issues)
map.whenReady(function() {
    // Tell Leaflet to recalculate sizes (useful if the map was initialized hidden or container size changed)
    setTimeout(function() {
        try { map.invalidateSize(); } catch (e) {}
        try { map.setView(defaultCenter, map.getZoom()); } catch (e) {}
    }, 50);
});

// Keep the map centered on window resize so it appears centered visually
window.addEventListener('resize', function() {
    try { map.invalidateSize(); } catch (e) {}
    try { map.setView(defaultCenter, map.getZoom()); } catch (e) {}
});

// Keep track of pins (id -> { id, name, marker })
var pins = {};

// Reference to the hazard list container (left sidebar). We'll add pins here.
var pinListContainer = document.getElementById('hazard-list');

// Sidebar tab behavior: switch visible tab panel and update aria attributes
function initSidebarTabs() {
    try {
        var tabButtons = Array.prototype.slice.call(document.querySelectorAll('.tab-button'));
        tabButtons.forEach(function(btn) {
            btn.addEventListener('click', function() {
                activateTab(btn);
            });
            btn.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    activateTab(btn);
                }
            });
        });

        function activateTab(button) {
            var allButtons = document.querySelectorAll('.tab-button');
            allButtons.forEach(function(b) {
                b.classList.remove('active');
                b.setAttribute('aria-selected', 'false');
            });
            button.classList.add('active');
            button.setAttribute('aria-selected', 'true');

            var panels = document.querySelectorAll('.tab-panel');
            panels.forEach(function(p) { p.hidden = true; });
            var targetId = button.getAttribute('aria-controls');
            var target = document.getElementById(targetId);
            if (target) target.hidden = false;
        }
    } catch (e) { /* fail silently if sidebar not present */ }
}

// initialize sidebar tabs and theme toggle on load
document.addEventListener('DOMContentLoaded', function() { 
    initSidebarTabs(); 
    initThemeToggle();
});

// Theme toggle: persists user's choice in localStorage and updates UI
function applyTheme(theme) {
    if (theme === 'light') {
        document.documentElement.classList.add('light-mode');
    } else {
        document.documentElement.classList.remove('light-mode');
    }
    var btn = document.getElementById('theme-toggle');
    if (btn) {
        btn.setAttribute('aria-pressed', theme === 'light' ? 'true' : 'false');
        btn.textContent = theme === 'light' ? '‚òÄÔ∏è' : 'üåô';
    }
}

function initThemeToggle() {
    try {
        var stored = null;
        try { stored = localStorage.getItem('hazardmap-theme'); } catch (e) { stored = null; }
        var initial = stored || 'dark';
        applyTheme(initial);

        var btn = document.getElementById('theme-toggle');
        if (!btn) return;
        btn.addEventListener('click', function() {
            var isLight = document.documentElement.classList.contains('light-mode');
            var next = isLight ? 'dark' : 'light';
            applyTheme(next);
            try { localStorage.setItem('hazardmap-theme', next); } catch (e) {}
        });
    } catch (e) { /* ignore */ }
}

// Query OpenStreetMap via Overpass for the closest building and the nearest named POI.
// Returns a Promise resolving to { building: {name,dist}|null, poi: {name,dist}|null }
function getBuildingAndPOI(latlng, radiusMeters) {
    radiusMeters = radiusMeters || 300;
    var lat = latlng.lat;
    var lon = latlng.lng;
    var url = 'https://overpass-api.de/api/interpreter';

    function fetchOverpass(query) {
        return fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: 'data=' + encodeURIComponent(query)
        }).then(function(resp) {
            if (!resp.ok) return null;
            return resp.json();
        }).catch(function() { return null; });
    }

    // Query for buildings and named features in parallel to reduce total time
    var qBuilding = '[out:json][timeout:15];(node(around:' + radiusMeters + ',' + lat + ',' + lon + ')["building"];way(around:' + radiusMeters + ',' + lat + ',' + lon + ')["building"];relation(around:' + radiusMeters + ',' + lat + ',' + lon + ')["building"];);out center tags;';
    var qNamed = '[out:json][timeout:15];(node(around:' + radiusMeters + ',' + lat + ',' + lon + ')["name"];way(around:' + radiusMeters + ',' + lat + ',' + lon + ')["name"];relation(around:' + radiusMeters + ',' + lat + ',' + lon + ')["name"];);out center tags;';

    return Promise.all([fetchOverpass(qBuilding), fetchOverpass(qNamed)]).then(function(results) {
        var jsonB = results[0];
        var jsonN = results[1];
        var out = { building: null, poi: null };

        function capitalize(s) {
            if (!s) return s;
            return s.charAt(0).toUpperCase() + s.slice(1);
        }

        function getTypeFromTags(tags, preferBuilding) {
            if (!tags) return null;
            // Prefer obvious POI keys for readable type
            var keys = ['amenity','tourism','shop','leisure','historic','landuse','office','man_made','building'];
            if (preferBuilding) {
                // ensure 'building' is considered first when preferBuilding
                keys = ['building','amenity','tourism','shop','leisure','historic','landuse','office','man_made'];
            }
            for (var i=0;i<keys.length;i++) {
                var k = keys[i];
                if (tags[k]) {
                    var v = tags[k];
                    // ignore boolean 'yes' for building
                    if (k === 'building' && v.toLowerCase() === 'yes') continue;
                    // make a readable label: e.g. amenity=library -> 'Library'
                    if (k === 'building') return 'Building' + (v && v.toLowerCase() !== 'yes' ? ' ('+v+')' : '');
                    if (k === 'landuse') return capitalize(v);
                    return capitalize(v.replace('_',' '));
                }
            }
            return null;
        }

        if (jsonB && jsonB.elements && jsonB.elements.length > 0) {
            var nearestB = null;
            var minDistB = Infinity;
            jsonB.elements.forEach(function(el) {
                var elLat = el.lat;
                var elLon = el.lon;
                if ((!elLat || !elLon) && el.center) {
                    elLat = el.center.lat;
                    elLon = el.center.lon;
                }
                if (elLat && elLon) {
                    // skip elements not currently visible on the map
                    try {
                        var pt = L.latLng(elLat, elLon);
                        if (map && map.getBounds && !map.getBounds().contains(pt)) return;
                    } catch (e) {
                        // if Leaflet isn't available for some reason, fall back to including the element
                    }
                    var d = latlng.distanceTo(L.latLng(elLat, elLon));
                    if (d < minDistB) {
                        // only include buildings that have an explicit name tag
                        if (el.tags && el.tags.name) {
                            minDistB = d;
                            var displayName = el.tags.name;
                            var typeLabel = getTypeFromTags(el.tags, true) || 'Building';
                            nearestB = { name: displayName, dist: d, type: typeLabel };
                        }
                    }
                }
            });
            if (nearestB) out.building = nearestB;
        }

        if (jsonN && jsonN.elements && jsonN.elements.length > 0) {
            var nearestN = null;
            var minDistN = Infinity;
            jsonN.elements.forEach(function(el) {
                var elLat = el.lat;
                var elLon = el.lon;
                if ((!elLat || !elLon) && el.center) {
                    elLat = el.center.lat;
                    elLon = el.center.lon;
                }
                if (elLat && elLon) {
                    // skip elements not currently visible on the map
                    try {
                        var pt2 = L.latLng(elLat, elLon);
                        if (map && map.getBounds && !map.getBounds().contains(pt2)) return;
                    } catch (e) {}
                    var d = latlng.distanceTo(L.latLng(elLat, elLon));
                    if (d < minDistN) {
                        // only include named elements
                        if (el.tags && el.tags.name) {
                            minDistN = d;
                            var displayName = el.tags.name;
                            var typeLabel = getTypeFromTags(el.tags, false) || 'Place';
                            nearestN = { name: displayName, dist: d, type: typeLabel };
                        }
                    }
                }
            });
            if (nearestN) out.poi = nearestN;
        }

        // If both are null, try Nominatim for a fallback name (address/display)
        if (!out.building && !out.poi) {
            return reverseGeocodeName(latlng).then(function(r) {
                if (r) out.poi = r;
                return out;
            }).catch(function() { return out; });
        }

        // If building exists but poi doesn't, attempt reverse geocode for poi (address)
        if (out.building && !out.poi) {
            return reverseGeocodeName(latlng).then(function(r) {
                if (r) out.poi = r;
                return out;
            }).catch(function() { return out; });
        }

        return out;
    }).catch(function() { return { building: null, poi: null }; });
}

// Fallback: use Nominatim reverse geocoding to get a nearby display name
function reverseGeocodeName(latlng) {
    var url = 'https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=' + latlng.lat + '&lon=' + latlng.lng;
    return fetch(url).then(function(resp) {
        if (!resp.ok) return null;
        return resp.json();
    }).then(function(data) {
        if (!data) return null;
        if (data.name) return { name: data.name, dist: 0 };
        if (data.display_name) return { name: data.display_name, dist: 0 };
        return null;
    }).catch(function() { return null; });
}

function addPinToList(id, name, marker) {
    if (!pinListContainer) return;

    // remove the placeholder 'No hazards listed yet.' when first item is added
    var firstPlaceholder = pinListContainer.querySelector('.muted');
    if (firstPlaceholder) firstPlaceholder.remove();

    var item = document.createElement('div');
    item.className = 'pin-item';
    item.setAttribute('data-pin-id', id);
    // make the item focusable for keyboard users so hover-style reveal also works with focus
    item.setAttribute('tabindex', '0');

    var label = document.createElement('span');
    label.className = 'pin-label';
    label.textContent = name;
    // ensure label is readable inside the hazard list (force black)
    label.style.color = '#000';
    item.appendChild(label);

    // find nearest landmark to this marker using Overpass (async)
    var landmarkSpan = document.createElement('span');
    landmarkSpan.className = 'pin-landmark';
    landmarkSpan.textContent = 'Searching...';
    landmarkSpan.style.color = '#333';
    // do the async lookup and update the UI when ready
    (function(marker, landmarkSpan) {
        var latlng = marker.getLatLng();
        getBuildingAndPOI(latlng, 400).then(function(res) {
            if (!res) {
                landmarkSpan.textContent = 'No landmark';
                return;
            }
            var parts = [];
            if (res.building && res.building.name) {
                parts.push((res.building.type || 'Building') + ': ' + res.building.name + ' (' + Math.round(res.building.dist) + ' m)');
            }
            if (res.poi && res.poi.name) {
                // avoid duplicating same label
                var poiLabel = res.poi.name;
                if (!res.building || (res.building.name !== poiLabel)) {
                    parts.push('Nearest: ' + (res.poi.type || 'Place') + ': ' + poiLabel + ' (' + Math.round(res.poi.dist) + ' m)');
                }
            }
            if (parts.length === 0) {
                landmarkSpan.textContent = 'No nearby named landmark';
            } else {
                landmarkSpan.textContent = parts.join(' ‚Ä¢ ');
            }
        }).catch(function() {
            landmarkSpan.textContent = 'No landmark';
        });
    })(marker, landmarkSpan);
    // container for right-side controls (landmark + delete)
    var controls = document.createElement('div');
    controls.style.display = 'inline-flex';
    controls.style.alignItems = 'center';
    controls.appendChild(landmarkSpan);

    // delete button
    var del = document.createElement('button');
    del.className = 'pin-delete';
    del.setAttribute('aria-label', 'Delete pin ' + name);
    del.textContent = '‚úï';
    // stop click from bubbling to the item click
    del.addEventListener('click', function(ev) {
        ev.stopPropagation();
        var doDelete = confirm('Delete pin "' + name + '"?');
        if (!doDelete) return;
        // remove marker from map and from pins object
        try { marker.remove(); } catch (e) { if (map.hasLayer(marker)) map.removeLayer(marker); }
        delete pins[id];
        // remove the list item
        if (item.parentNode) item.parentNode.removeChild(item);
    });
    controls.appendChild(del);

    item.appendChild(controls);

    // click list item to pan to marker and open popup
    item.addEventListener('click', function() {
        map.setView(marker.getLatLng(), Math.max(map.getZoom(), 16));
        marker.openPopup();
    });

    pinListContainer.appendChild(item);
}

function updatePinNameInList(id, newName) {
    if (!pinListContainer) return;
    var item = pinListContainer.querySelector('[data-pin-id="' + id + '"]');
    if (item) {
        var label = item.querySelector('.pin-label');
        if (label) label.textContent = newName;
    }
}

// Add pin on click
map.on('click', function(e) {
    // Make sure pins stay within bounds
    if (
        e.latlng.lat >= bounds[0][0] && e.latlng.lat <= bounds[1][0] &&
        e.latlng.lng >= bounds[0][1] && e.latlng.lng <= bounds[1][1]
    ) {
        // Ask the user for a name for this pin
        var name = prompt('Enter a name for this pin:', '');
        if (name === null) {
            // User cancelled ‚Äî don't create the marker
            return;
        }
        name = name.trim();
        if (name === '') {
            name = 'Unnamed pin';
        }
        var marker = L.marker([e.latlng.lat, e.latlng.lng]).addTo(map);
        marker.bindPopup(name).openPopup();

        // Create an id for this pin and store it
        var id = 'pin-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
        pins[id] = { id: id, name: name, marker: marker };

        // Add to bottom list (also shows nearest landmark)
        addPinToList(id, name, marker);

        // Allow renaming the pin by double-clicking it
        marker.on('dblclick', function() {
            var current = marker.getPopup() ? marker.getPopup().getContent() : '';